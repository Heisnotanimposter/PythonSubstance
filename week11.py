# -*- coding: utf-8 -*-
"""week11.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/191JL3EaKkuMQBus7LNA6a5rl-0T-AjzT
"""

#objectclass
#2245051 이승원
#22/05/18

class Call:
    def __call__(self):
        print('__call__() 메서드가 호출되었습니다.')
        print('__call__() 메서드는 클래스를 함수처럼 호출할 수 있도록 해 줍니다.')

myCall= Call()
myCall()

class Decorator:
    def __init__(self, func):
        print("Decorator 클래스의 객체가 생성되었습니다...")
        self.func= func
    def __call__(self):
        print (f"{ self.func.__name__}() 함수의 장식이 시작되었습니다.")
        self.func()
        print (f"{ self.func.__name__}() 함수의 장식이 끝났습니다.")

def myFunction():
    print("여기는 myFunction() 함수입니다.")

myFunction = Decorator(myFunction)
myFunction()

iterator = range(3).__iter__()
try:
    print(iterator.__next__())
    print(iterator.__next__())
    print(iterator.__next__())
    print(iterator.__next__())
except Exception as e:
    print(e)
    print('예외가 발생했습니다.', e)

class MyRange:
    def __init__(self, start, end):
        self.current = start
        self.end = end
    def __iter__(self):
        return self
    def __next__(self):
        if self.current < self.end:
            current = self.current
            self.current += 1
            return current
        else:
            raise StopIteration()

for i in MyRange(0, 5):
    print(i)

class Counter:
    def __init__(self, stop):
        self.current = 0   
        self.stop = stop    
    def __iter__(self):                 
        return self  
    def __next__(self):                
        if self.current < self.stop:   
            return_value = self.current            
            self.current += 1           
            return return_value         
        else:                         
            raise StopIteration

counter =iter(Counter(5))
for i in range(5):
    print(next(counter))

def generator():
    yield 1
    yield 2
    yield 3
    yield 4
    yield 5
iterator=generator()
print(iterator.__next__())
print(iterator.__next__())
print(iterator.__next__())
print(iterator.__next__())

def yieldRange(start, end):
    current = start
    while current < end:
        yield current
        current += 1
    return

for i in yieldRange(0, 5):
    print(i)

#AbstractBaseClass
#2245051 이승원
#22/05/18

from abc import ABCMeta
from abc import abstractmethod

class Duck(AbstractDuck):
	def Quack(self):
		print("[Duck] Quack")	
    duck = Duck()
    duck.Quack()
[Duck] Quack

from abc import *
class StudentBase(metaclass=ABCMeta):
    @abstractmethod
    def study(self):
        pass
    @abstractmethod
    def goToSchool(self):
        pass
class Student(StudentBase):
    def study(self):
        print('공부하는 중입니다.')
    def goToSchool(self):
        print('학교가는 중입니다.')
gilDong = Student()
gilDong.study()
gilDong .goToSchool()

gilDong = Student()
gilDong.study()
gilDong .goToSchool()

from abc import abstractmethod, ABCMeta

class Question(metaclass=ABCMeta):
    def __init__(self, text):
        self.text=text
    @abstractmethod
    def askTheUser(self):
        pass

class YesNoQuestion(Question):
    def __init__(self, text):
        Question.__init__(self, text)
    def askTheUser(self):
        print(self.text)
        print("YES or NO … ?")

class FreeTextQuestion(Question):
    def __init__(self, text):
        Question.__init__(self, text)
    def askTheUser(self):
        print(self.text)
        print("Well…? What's the answer…?")

def getQuestions():
    Questions=list()
    Questions.append(YesNoQuestion("Are you happy?"))
    Questions.append(FreeTextQuestion("Why or why not?"))
    return Questions
    
Questions = getQuestions()
for question in Questions:
    question.askTheUser()
    print()

from abc import ABC, ABCMeta, abstractmethod
from datetime import datetime
#from Menu import Menu

class ILogger(ABC):
    __metaclass__ = ABCMeta
    @abstractmethod
    def WriteLog(self, message):
        pass
class FileLogger(ILogger):
    def __init__(self, path):
        self.path=path
        self.logFile = open(path, "w")
    def WriteLog(self, message):
        with open(self.path, "a") as myFile:
            myFile.write(str(datetime.now()) + message+"\n")
class ConsoleLogger(ILogger):
    def __init__(self):
        pass
    def WriteLog(self, message):
        print(str(datetime.now()) + message)
class ClimateMonitor():
    def __init__(self, logger):
        self.logger=logger
    def start(self):
        temperature= input("온도를 입력해주세요.: ")
        while temperature !="":
            self.logger.WriteLog("\t현재 온도 : "+ temperature)
            temperature= input("온도를 입력해주세요.: ")

title = "어디에 로깅할까요?"
contents = ["파일(Mylog.txt)", "콘솔"]
#myMenu=Menu(title, contents)
#myMenu.print()
#myMenu.getMenuNumber()
"""
while not myMenu.isExit():
    if myMenu.MenuNumber==1:
        fileName=input("로그 파일 이름을 입력하세요 : ")
        if fileName=="":
            fileName="myLog.txt"
        monitor= ClimateMonitor(FileLogger(fileName))
        monitor.start()
    elif myMenu.MenuNumber==2:
        monitor= ClimateMonitor(ConsoleLogger())
        monitor.start()
    else:
        print("메뉴 객체에서는 도달할 수 없습니다.~~~")
    myMenu.print()
    myMenu.getMenuNumber()
"""
print("안녕히 가세요~~~")

from abc import ABC, ABCMeta, abstractmethod
#from Menu import *
class Gamer(ABC):
    __metaclass__ = ABCMeta
    Winner = "없음"
    PlayList = ['가위', '바위', '보']
    isGameOver=False
    def __init__(self, name):
        self._name = name
        self._playResult=''
    @property
    def Name(self):
        return self._name
    @property
    def playResult(self):
        return self._playResult
    @playResult.setter
    def playResult(self,value):
        self._playResult = value
    @abstractmethod
    def play(self):
        pass

def _getWinner(self, otherPalyer):
        if self.playResult =='가위':
            if otherPalyer.playResult =='가위':
                Gamer.Winner='없음'
            elif otherPalyer.playResult =='바위':
                Gamer.Winner=otherPalyer.Name
            elif otherPalyer.playResult =='바위':
                Gamer.Winner=self.Name
        if self.playResult =='바위':
            if otherPalyer.playResult =='가위':
                Gamer.Winner=self.Name
            elif otherPalyer.playResult =='바위':
                Gamer.Winner='없음'
            elif otherPalyer.playResult =='바위':
                Gamer.Winner=otherPalyer.Name
        if self.playResult =='보':
            if otherPalyer.playResult =='가위':
                Gamer.Winner=otherPalyer.Name
            elif otherPalyer.playResult =='바위':
                Gamer.Winner=self.Name
            elif otherPalyer.playResult =='바위':
                Gamer.Winner='없음'

def printGameResult(self, otherPalyer):
        self._getWinner(otherPalyer)
        print("{0} : {1}".format(self.Name, self.playResult))
        print("{0} : {1}".format(otherPalyer.Name, otherPalyer.playResult))
        if Gamer.Winner == '없음':
            print('{0}님이 {1}님과 비겼습니다.'.format(self.Name, otherPalyer.Name))
        elif Gamer.Winner==self.Name:
            print('{0}님이 {1}님을 이겼습니다.'.format(self.Name, otherPalyer.Name))
        else:
            print('{0}님이 {1}님을 이겼습니다.'.format(otherPalyer.Name, self.Name))

def _getWinner(self, otherPalyer):
        if self.playResult =='가위':
            if otherPalyer.playResult =='가위':
                Gamer.Winner='없음'
            elif otherPalyer.playResult =='바위':
                Gamer.Winner=otherPalyer.Name
            elif otherPalyer.playResult =='바위':
                Gamer.Winner=self.Name
        if self.playResult =='바위':
            if otherPalyer.playResult =='가위':
                Gamer.Winner=self.Name
            elif otherPalyer.playResult =='바위':
                Gamer.Winner='없음'
            elif otherPalyer.playResult =='바위':
                Gamer.Winner=otherPalyer.Name
        if self.playResult =='보':
            if otherPalyer.playResult =='가위':
                Gamer.Winner=otherPalyer.Name
            elif otherPalyer.playResult =='바위':
                Gamer.Winner=self.Name
            elif otherPalyer.playResult =='바위':
                Gamer.Winner='없음'

def printGameResult(self, otherPalyer):
        self._getWinner(otherPalyer)
        print("{0} : {1}".format(self.Name, self.playResult))
        print("{0} : {1}".format(otherPalyer.Name, otherPalyer.playResult))
        if Gamer.Winner == '없음':
            print('{0}님이 {1}님과 비겼습니다.'.format(self.Name, otherPalyer.Name))
        elif Gamer.Winner==self.Name:
            print('{0}님이 {1}님을 이겼습니다.'.format(self.Name, otherPalyer.Name))
        else:
            print('{0}님이 {1}님을 이겼습니다.'.format(otherPalyer.Name, self.Name))

class Person(Gamer):
        def __init__(self, name='사용자'):
            super().__init__(name)
        def play(self):
            title="가위바위보:"
            myMenu=Menu(title, Gamer.PlayList)
            myMenu.print()
            myMenu.getMenuNumber()

            if myMenu.menuNumber != myMenu.ExitNumber:
                self.playResult=Gamer.PlayList[myMenu.MenuNumber-1]
            else:
                Gamer.isGameOver=True
import random
class Computer(Gamer):
    def __init__(self, name='컴퓨터'):
        super().__init__(name)
    def play(self):
        self.playResult = random.choice(Gamer.PlayList)

#from RockPaperScissors import *
ComputerPlayer = Computer('컴퓨터')
PersonPlayer=Person(input("이름을 입력해 주세요:"))
#PersonPlayer.play()
while(not Gamer.isGameOver):
    ComputerPlayer.play()
    #ComputerPlayer.printGameResult(PersonPlayer)
    print()
    #PersonPlayer.play()
print("안녕히 가세요~~~")

